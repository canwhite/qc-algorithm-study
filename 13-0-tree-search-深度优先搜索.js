/*
补充一下二叉树的基础知识

----------------------------
二叉树有两种主要的形式：

* 满二叉树
* 完全二叉树


1.满二叉树：
深度为k，有2^k-1个结点的二叉树，除了顶部一个结点外，其它每一层都是正好满的

2.完全二叉树：
一棵深度为k的有n个结点的二叉树，
对树中的结点按从上至下、从左到右的顺序进行编号，
如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。



PS：二叉树和堆的关系

堆就是一个完全二叉树，也就是说堆是二叉树的一种




-------------------------------
将二叉树根据作用分类

* 二叉搜索树
* 平衡二叉搜索树（是二叉搜索树的子项）




1.  二叉搜索树 （二叉查找树、二叉排序树）

二叉搜索树是有数值的，二叉搜索树是一个有序树
也有以下特征：
(1) 若它的左子树不空，则左子树的所有结点的值均小于它的根结点的值
(2) 若它的右子树不空，则右子树的所有节点的值均大于它的根结点的值
(3) 它的左、右子树也分别为二叉搜索树

比较的是左子树，根节点和右子树


2.平衡二叉搜索树
它是二叉搜索树的子集
有以下特征：
* 它是一棵空树
* 它的左右两个子树的------高度差的绝对值不超过1----
* 左右两个子树都是一棵平衡二叉树。

深度优先搜索----------

通过递归实现深度优先搜索
深度优先查询的特点是沿着一条路径不断往下，直到不能再继续为止，
然后再折返，开始搜索下一条候补路径

深度优先搜索传入node和维系一个最终的数组
然后根据需要递归的标识符，不断往下

实际上如果从一个树的角度来看的话，是先高再宽

----------------------




*/


//递归的方式：
//确认参数，确认单次逻辑，确定返回值
let depth1 = (node,nodeList = [])=>{
    //node不能为null
    if(node != null){
        //添加节点的操作
        nodeList.push(node);
        let children = node.children ||[];
        //for循环时横向，depth1是纵向
        for(let i = 0;i<children.length;i++){
            depth1(children[i],nodeList);
        }
    }
    return nodeList;
}

//对obj的处理
let obj = { 
    children: [
        { 
            index: 0, 
            children: [
                { 
                    index: 1, 
                    children: [{ 
                        index: 3 
                    }] 
                }
            ] 
        }, 
        { 
            index: 4 
        }, 
        { 
            index: 5, 
            children: [{ 
                index: 7, 
                children: [{ 
                    index: 8 
                }] 
            }] 
        }, 
        { 
            index: 6 
        }
    ] 
}

let arr = depth1(obj);
console.log("-----",arr);



