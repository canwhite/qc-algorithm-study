/*
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。
该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。
也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，
其中 n > 1 给你n ，请计算 F(n) 。

示例 1： 
输入：2 
输出：1 
解释：F(2) = F(1) + F(0) = 1 + 0 = 1

示例 2： 
输入：3 
输出：2 
解释：F(3) = F(2) + F(1) = 1 + 1 = 2

示例 3： 
输入：4 
输出：3 
解释：F(4) = F(3) + F(2) = 2 + 1 = 3   

提示：
0 <= n <= 30

明显是后边的结果取决于前边的状态，所以是一个动规题目
----------------------------------------
思路：
简单题目是用来加深对解题方法论的理解的。

然后我们来思考下动规五部曲：
1.确定dp数组以及下标的含义
    dp[i]的定义为：
    第i个数的斐波那契数值是dp[i]
2.确定递推公式
    为什么这是一道非常简单的入门题目呢？
    因为题目已经把递推公式直接给我们了：
    状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];
3.dp数组如何初始化？
    题目中把如何初始化也给我们了
    dp[0] = 0;
    dp[1] = 1;
4.确定遍历顺序
    从递归公式dp[i] = dp[i - 1] + dp[i - 2];
    中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，
    那么遍历的顺序一定是从前到后遍历的
5.举例推导递推公式
    按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，
    我们来推导一下，当N为10的时候，dp数组应该是如下的数列：
    0 1 1 2 3 5 8 13 21 34 55  
    
如果代码写出来，发现结果不对，
就把dp数组打印出来看看和我们推导的数列是不是一致的。

*/

var fib = function(n){
    let dp = [0,1];
    //正向遍历
    for(let i=2;i<=n;i++){
        dp[i] = dp[i-1]+dp[i-2];
    }
    console.log(dp);
    return dp[n];
}

console.log(fib(4))