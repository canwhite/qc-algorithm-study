/* 

----------二叉树概念介绍-----------

二叉树的每个结点最多有两个子结点，所以叫做二叉树

function TreeNode(val,left,right){
    this.val = val || "";
    this.left = left || null;
    this.right = right || null;
}

大家会发现二叉树的定义 和链表是差不多的，相对于链表 ，
二叉树的节点里多了一个指针， 有两个指针，指向左右孩子.



二叉树有两种主要的形式：
1.满二叉树
2.完全二叉树

* 满二叉树：
深度为k，有2^k-1个结点的二叉树。
除了顶部一个结点外，其它每一层都是正好满的

* 完全二叉树：
树枝是满的，一层可以不满，如果枝儿上少了一个，就不能叫做完全二叉树
堆就是一个完全二叉树，也就是说堆是二叉树的一种


二叉树根据作用又区分：
1.二叉搜索树
2.平衡二叉搜索树（二叉搜索树的子项）

*  二叉搜索树
二叉搜索树是有数值的，二叉搜索树是一个有序树
也有以下特征：
(1) 若它的左子树不空，则左子树的所有结点的值均小于它的根结点的值
(2) 若它的右子树不空，则右子树的所有节点的值均大于它的根结点的值
(3) 它的左、右子树也分别为二叉排序树

* 平衡二叉搜索树
特征：
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
它是二叉搜索树的子集
空树不说，
最主要的特征就是：左右两个子树的高度差的绝对值不超过1

C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，
所以map、set的增删操作时间时间复杂度是logn，
注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。
这些也是无序的，c++无序的用了嘻哈表

所以大家使用自己熟悉的编程语言写算法，
一定要知道常用的容器底层都是如何实现的，
最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！


----------二叉树的存储方式-------------
二叉树可以
* 链式存储
* 顺序存储
那么链式存储方式就用指针，顺序存储的方式就是用数组

顾名思义：
顺序存储的元素在内存中是连续分布的
链式存储则是通过指针把分布在各个地址的节点串联一起

链式存储我们讲链表的时候其实已经很熟悉，
所以我们来看看如何进行顺序存储？
其实就是用数组来存储二叉树，从上到下一层层的排

那么顺序存储如何遍历呢？
因为是一行填满了再添加另外一行，所以如果
父节点的数组下标是i,那么它的左孩子就是i*2 + 1,右孩子就是 i *2 +2; 

整体来说，用链式保存的二叉树，更有利于我们理解，所以一般都是用链式存储二叉树
但是大家要了解，用数组依然可以表示二叉树

---------------二叉树的遍历方式-----------------
二叉树主要是两种遍历方式：
1.深度优先遍历：先往深走，遇到叶子结点再往回走
2.广度优先遍历：一层一层的遍历

这两种遍历时图论中最基本的两种遍历方式，后面在介绍图论时候还会介绍到。

* 深度优先遍历
    前序遍历(中间节点在前，递归法、迭代法)
    中序遍历(中间节点在中，递归法、迭代法)
    后续遍历(中间节点在后，递归法、迭代法)

* 广度优先遍历
    层次遍历

最后再说一说二叉树中深度优先和广度优先遍历实现方式，
我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。

之前我们讲栈与队列的时候，
就说过栈其实就是递归的一种是实现结构，
也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，
这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

这里其实我们又了解了栈与队列的一个应用场景了。

具体的实现我们后面都会讲的，这里大家先要清楚这些理论基础。

*/

//基本二叉树的设计,这是一个无序的二叉树
