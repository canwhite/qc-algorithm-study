/*-----------------------------------------------

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:
输入: n = 4, k = 2
输出:
[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]

组合问题是回溯法的经典问题，
暴力解法是for循环
int n = 4;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        cout << i << " " << j << endl;
    }
}
但是输入n=100，k=3就需要三层for循环，
如果n为100，k为50呢？阿西
直接写不来了，层层嵌套
咋整？
回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望
-------------------------------------------------
可以看出这个棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不在重复取。
第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，
分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。
每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。
图中可以发现n相当于树的宽度，k相当于树的深度。
-------------------------------------------------
那么如何在这个树上遍历，然后收集到我们要的结果集呢？
图中每次搜索到了叶子节点，我们就找到了一个结果。
相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。
-------------------------------------------------
回溯法三部曲：
（1）递归函数的返回值以及参数 :
除了n和k，还需要一个startIndex，
每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex。
（2）回溯函数终止条件
path这个数组的大小如果达到k，
说明我们找到了一个子集大小为k的组合了，
在图中path存的就是根节点到叶子节点的路径。
此时用result二维数组，把path保存起来，并终止本层递归。
（3）单层搜索的过程
回溯法的搜索过程就是一个树型结构的遍历过程，
for循环用来横向遍历，
递归的过程是纵向遍历
for循环每次从startIndex开始遍历，然后用path保存取到的节点i。

-----------------------------------------------
剪枝操作
如果n=4，k=4
这时候我们会知道结果是[1,2,3,4]
那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 
在第二层for循环，从元素3开始的遍历都没有意义了。
所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。
如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么就没有必要搜索了。
已经不足我们需要的元素个数了，那么就没有必要搜索了。
注意代码中i，就是for循环里选择的起始位置。

没剪枝之前：
for (int i = startIndex; i <= n; i++) {...}
接下来看一下优化过程如下：
1.已经选择的元素个数：path.size();
2.还需要的元素个数为: k - path.size();
3.右边界: n - (k - path.size()) + 1，开始遍历

为什么有个+1呢?
因为包括起始位置，我们要是一个左闭的集合。
eg:
n = 4，
k = 3，
目前已经选取的元素为0（path.size为0），

n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。
从2开始搜索都是合理的，可以是组合[2, 3, 4]。

所以优化之后的for循环是：

for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置
-----------------------------------------------*/

//普通算法
let result = [];
let path = [];
var combine = function(n,k){
    result = [];
    combineHelper(n, k, 1)
    return result;
}

const combineHelper = (n,k,startIndex)=>{
    //如果满足条件，结束单次添加
    if(path.length === k){
        result.push([...path]);
        return;
    }
    //普通回溯，一些不需要循环的部分也循环了
    /* for(let i = startIndex;i<=n ;i++){
        //处理节点
        path.push(i);
        //递归，将满足条件的结构给到result
        combineHelper(n,k,i+1);
        //回溯，撤销处理结果，
        path.pop();
    } */
    //减枝,右边界消减
    for(let i = startIndex; i<= n-(k-path.length)+1;i++){
        path.push(i);
        //递归，将满足条件的结构给到result
        combineHelper(n,k,i+1);
        //回溯，撤销处理结果，
        path.pop();
    }

}
console.log(combine(4,2));


