/* 
今天我们就来说一说滚动数组，
其实在前面的题目中我们已经用到过滚动数组了，
就是把二维dp降为一维dp，

那么我们通过01背包，来彻底讲一讲滚动数组！

接下来还是用如下这个例子来进行讲解

背包最大重量为4。

物品为：

重量	价值
物品0	1	15  
物品1	3	20
物品2	4	30

wight[0] = 1, value[0] = 15

问背包能背的物品最大价值是多少？ 
-----------------------------------------
一维dp数组(滚动数组)
滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层

其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，
表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);

再想与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，
只用dp[j]（一维数组，也可以理解是一个滚动数组）

dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。

dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
一定要时刻记住这里i和j的含义，要不然很容易看懵了。

------------------------------------------
动态分析五部曲：
------------------------------------------
1.确定dp数组的定义
在一维dp数组中，
dp[j]表示：容量为j的背包，所背的物品价值最大为dp[j]


------------------------------------------
2.一维dp数组的递推公式
dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？

dp[j]可以通过dp[j - weight[i]]推导出来，
dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示容量为 j - 物品i重量的
背包加上物品i的价值。
（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择，一个是取自己dp[j]，
一个是取dp[j - weight[i]] + value[i]，
指定是取最大的，毕竟是求最大价值，

所以递推公式为：
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

-------------------------------------------
3.一维dp数组如何初始化

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，
那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

dp数组在推导的时候一定是取价值最大的数，
(1)如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，
(2)如果题目给的价值有负数，那么非0下标就要初始化为负无穷

这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。
那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

-------------------------------------------
4.一维dp数组遍历顺序

二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。

举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

如果正序遍历

dp[1] = dp[1 - weight[0]] + value[0] = 15

dp[2] = dp[2 - weight[0]] + value[0] = 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒叙遍历，就可以保证物品只放入一次呢？

倒叙就是先算dp[2]

dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）

dp[1] = dp[1 - weight[0]] + value[0] = 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

那么问题又来了，为什么二维dp数组历的时候不用倒叙呢？

因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！

-------
再来看看两个嵌套for循环的顺序，
代码中是先遍历物品嵌套遍历背包容量，
那可不可以先遍历背包容量嵌套遍历物品呢？

不可以！


dp[2] = dp[2 - weight[0]] + value[0] = 15 
dp[2] = dp[2 - weight[1]] + value[1] = 20 
dp[2] = dp[2 - weight[2]] + value[2] = 30 

因为前边的额dp[2-weight[i]]这时候还没有值，等于只放入了一个物品，

所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！，这一点大家一定要注意。

--------------------------------------------------
5.举例推到dp数组
一维dp，分别用物品0、物品1、物品2来遍历背包

*/
//这里要理解i和j的大小
//i是物品个数，从物品0开始算，正好weight.length-1个
//j是背包容量，是一个数字，在原有容量的基础上，还需要添加一种情况为容量0才合理
//所以size+1

function testWeightBagProblem(weight,value,size){
    const len = weight.length;
    dp = Array(size+1).fill(0);
    //物品从物品0开始
    for(let i=0;i<len;i++){//物品遍历
        //背包遍历
        //如果容量大于当前物品重量，我们就进行操作
        for(let j = size;j >= weight[i];j--){
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    return dp[size];
}

console.log(testWeightBagProblem([1, 3, 4, 5], [15, 20, 30, 55], 6));