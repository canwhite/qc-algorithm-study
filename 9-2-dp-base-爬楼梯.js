/* 
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。
你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1： 
输入： 2 
输出： 2 
解释： 有两种方法可以爬到楼顶。
1 阶 + 1 阶
2 阶

示例 2： 
输入： 3 
输出： 3 
解释： 有三种方法可以爬到楼顶。

1 阶 + 1 阶 + 1 阶
1 阶 + 2 阶
2 阶 + 1 阶 

-----------------------------------
思路：

本题大家如果没有接触过的话，
会感觉比较难，多举几个例子，就可以发现其规律。

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。

那么第一层楼梯再跨两步就到第三层 ，
第二层楼梯再跨一步就到第三层。

所以到第三层楼梯的状态可以由第二层楼梯
和到第一层楼梯状态推导出来，
那么就可以想到动态规划了。
---------------------------------------
动态五部曲：

1.确定dp数组以及下标的含义
    dp[i]如果是最终上楼梯的方法数的话，i就是层数
2.确定递推公式
    如何可以推出dp[i]呢？

    这里注意i是层数，dp[i]是方法数
    let i = 3;
    i=3(三层楼)，dp[i]=3(三种方法)
    i-1=2(二层楼)，dp[i-1]=2(两种方法)
    i-2=1(一层楼)，dp[i-2]=1(一种方法)
    我们可以把它写作一个简单数组的关系，然后使用归纳的方法
    下标i     | 1 | 2 | 3 | 4 | 5
    —————————————————————————————
    方法dp[i] | 1 | 2 | 4 | 5 | 8
    
    so：
    可以看到dp[1]=1,dp[2]=2,dp[3]=3
    dp[3]=dp[2]+dp[1]
    往后算也成立，所以
    我们可以得到dp[i] = dp[i-1]+dp[i-2]
    在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。
    这体现出确定dp数组以及下标的含义的重要性！

    然后自己大致从基础举几个例子，就可以归纳出来了

3.dp数组如何初始化
    再回顾一下dp[i]的定义
    爬到第i层楼梯，有d[i]种方法
    那么i为0，dp[i]应该是多少呢，
    这个可以有很多解释，但都基本是直接奔着答案去解释的。
    例如强行安慰自己爬到第0层，也有一种方法，
    什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。

    但总有点牵强的成分。

    那还这么理解呢：我就认为跑到第0层，
    方法就是0啊，一步只能走一个台阶或者两个台阶，
    然而楼层是0，直接站楼顶上了，
    就是不用方法，dp[0]就应该是0.

    其实这么争论下去没有意义
    大部分解释说dp[0]应该为1的理由其实是：
    如果dp[0]=1的话，递推的过程中dp[2]=dp[1]+dp[0]
    然后就往结果上靠去解释dp[0]=1

    从dp数组定义的角度来说， dp[0]=0也能说得通。
    需要注意的是：
    题目说了n是一个正整数，题目根本没说n有为0的情况
    所以本题不应该讨论dp[0]的初始化！
    我相信dp[1]=1,dp[2]=2,这个初始化大家应该都没有争议的。
    ----------------
    所以我的原则是：
    不考虑dp[0]如何初始化，值初始化dp[1]=1,dp[2]=2
    然后从i=3，开始递推，这样才符合dp[i]的定义

4.确认遍历顺序
    从递归公式dp[i] = dp[i-1]+dp[i-2]中可以看出，
    遍历顺序一定是从前向后遍历的

5.举例推导dp数组
    举例当n为5的时候的dp table

*/

//常规方法
var climbStairs = function(n){
    var dp = [];
    dp[1]=1;
    dp[2]=2;
    for(var i =3;i<=n;i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
//用变量记录代替数组
var climbStairs1 = function(n){
    if(n<=2) return n;
    var a =1,b=2,sum=0;
    for(var i =3;i<=n;i++){
        sum = a+b;
        a = b;
        b = sum;
    }
    return b;
}

console.log(climbStairs(5));
console.log(climbStairs1(5));