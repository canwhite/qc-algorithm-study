/*======================================================
对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。
先对这几个概念做一下区分：
背包问题=>物品=>物品特征(价值w,体积v,每个物品的数量)=>数量判断
到数量的时候，就会分出几种:
1.只有一个=>不选|选一个 =>01背包，可以放多个物品，但是每件物品只能用一次
2.无数个  =>不选|选几个 =>完全背包
3.不同物品数量不同      =>多重背包
前三个都是混合背包的问题

4.按组打包每组最多选一个 =>分组背包


leetcode上连多重背包的题目都没有,所以题库告诉我们,
01背包和完全背包就够用了
而完全背包也是01背包稍作变化而来，
即：完全背包的物品数量是无限的
所以背包问题的理论基础重中之重是01背包，一定要理解透！

leetcode上没有纯01背包的问题，
都是01背包应用方面的题目，
也就是需要转化为01背包问题。

所以我先通过纯01背包问题，把01背包原理讲清楚，
后续再讲解leetcode题目的时候，
重点就是讲解如何转化为01背包问题了。

---------------------------------------------------

01背包：
有N件物品和一个最多能背重量为W的背包。
第i件物品的重量是weight[i],
得到的价值是value[i]
每件物品只能用一次，求解，
将哪些物品装入背包里物品价值总和最大


这是标准的背包问题，
以至于很多同学看了这个自然就会想到背包，
甚至都不知道暴力的解法应该怎么解了。

这样其实是没有从底向上去思考，
而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？

每一件物品其实只有两个状态，取或者不取，
所以可以使用回溯法搜索出所有的情况，
那么时间复杂度就是O(2^n)，这里的n表示物品数量。

所以暴力的解法是指数级别的时间复杂度。
进而才需要动态规划的解法来进行优化！

下边的讲解中，会使用这个例子：
背包最大重量为4；
	  重量 价值
物品0	1	15
物品1	3	20
物品2	4	30
问背包能背的物品最大价值是多少?
------------------------------------------------
二维dp数组01背包

1.确认dp数组以及下标得含义
------------------------------------------------
对于背包问题，有一种写法，是使用二维数组，
即dp[i][j]表示从下标0-i的物品任意选，放进容量为j的背包
价值总和最大是多少
要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的
牢记i是什么，j是什么，dp[i][j]是什么？

2.确认递推公式：
------------------------------------------------
我们可以从两个方向推出dp[i][j]
* 由dp[i - 1][j]推出，
	即背包容量为j，里面不放物品i的最大价值，
	此时dp[i][j]就是dp[i - 1][j]。
	(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，
	所以被背包内的价值依然和前面相同。)
* 由dp[i - 1][j - weight[i]]推出，
	dp[i - 1][j - weight[i]]表示为容量为j-weight[i]的背包，所背的最大价值
	那么dp[i - 1][j - weight[i]] + value[i] 就是背包放物品i得到的最大价值
简单理解，一个是取自己，一个是能放，放了之后的值
所以递推公式
dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i])

3.dp数组如何初始化
--------------------------------------------------
如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0
j=0，纵向为0
如果i=0，即物0的时候，
----
当 j < weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。
当j >= weight[0]是，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。
第一行为0或者物品0的价值
for (int j = 0 ; j < weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagWeight; j++) {
    dp[0][j] = value[0];
}
这样dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 
所以在第一行和第一列初始化之后，其他值的初始化就无所谓了，反正最后都会被求出来
所以，为了方便我们把其他值都初始化为0
// 初始化 dp
vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));
for (int j = weight[0]; j <= bagWeight; j++) {
    dp[0][j] = value[0];
}
到这里，初始化就讲完了
主要是因为是一个二维数组，所以从行和列两个维度去考虑，而不是靠感觉

4.确定递推顺序
----------------------------------------------------
先遍历物品还是先遍历背包重量呢？
其实都可以，但是先遍历物品更好理解。

先遍历物品的代码：
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; 
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
再看先遍历重量的代码：
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
p[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正左和正上两个方向），
那么先遍历物品还是先遍历重量都是依赖这两个
所以本质上没什么变化

5.举例推导dp数组
----------------------------------------------------
可以自己画一个二维数组图，并且代入公式，实验一下

=======================================================*/

//weight和value是物品两个属性的数组，size是背包容量
function testWeightBagProblem(weight,value,size){
	
	//-----注意区分，行列和下标，行列总比下标多1
	//-----下边循环的时候注意
	let rows = weight.length;
	let cols = size +1;
	
	//js创建二维数组,分几行
	let dp = Array.from({length: rows}).map(
		//每行情况
		() => Array(cols).fill(0)
	);
	
	//先说纵向rows，第一列，对应背包容量为0，价值为0
	for (const i in rows) {
		//当背包容量为0的时候，不用说最终价值也为0
		dp[i][0]=0;
	}
	
	//再说横向cols，第一行的初始化，对应物品价值
	let first_item_weight = weight[0];
	let first_item_value = value[0];
	for(var j =1;j<=cols;j++){
		if(first_item_weight <= j){
			dp[0][j] = first_item_value;
		}
	}
	
	//初始化一个最终值
	let res = 0;
	//因为第一行设置完了，所以我们从1开始，下标到3
	for(var i = 1; i< rows; i++){
		let cur_weight = weight[i];
		console.log("cur_weight",cur_weight);
		let cur_val = value[i];
		console.log("cur_val",cur_val);
		//因为第一列设置完了，所以从1开始，下标准到6
		for(var j = 1;j < cols;j++){
			//大了装不下
			if(cur_weight > j){
				dp[i][j] = dp[i-1][j]
				if(dp[i][j]>res) res = dp[i][j]
			//能装下的情况
			}else{
				dp[i][j] = Math.max(dp[i-1][j],dp[i - 1][j - cur_weight]+ cur_val)
				if(dp[i][j]>res) res = dp[i][j]
			}
		}
	}
	return res;
}
let result = testWeightBagProblem([1, 3, 4, 5], [15, 20, 30, 55], 6);
console.log(result);