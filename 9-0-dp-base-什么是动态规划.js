/*========================================================
1.什么是动态规划？
动态规划，英文：Dynamic Programming，简称DP，
如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的，
这一点区别于贪心，贪心没有状态推导，而是从局部直接选最优的

一个背包问题的例子：

有N件物品和一个最多能背重量为W 的背包。
第i件物品的重量是weight[i]，得到的价值是value[i] 。
每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

动态规划中dp[j]是由dp[j-weight[i]]推导出来的
然后取max(dp[j],dp[j-weight[i]]+value[i])

但如果是贪心呢？
每次那物品选一个最大的或者最小的就完事了，和上一个状态没有关系
所以贪心解决不了动态规划的问题

教科书上有最优子结构和重叠子问题这些，这些概念是
教科书上定义的，晦涩难懂不实用

大家知道动态规划是由前一个状态推导出来的，
而贪心是局部直接选最优的，对于刷题来说就够用了
-------------------------------------------------------
2.动态规划的解题步骤

做动态题目的时候，很多同学陷入一个误区，
就是认为把【状态转移公式】背下来，
照葫芦画瓢改改，就开始写代码
甚至把题目AC之后，都不太清除dp[i]表示的是什么

这是一种朦胧的状态，然后就把题给过了
遇到稍微难一点的，可能直接就不会了
然后看题解，然后继续照葫芦画瓢陷入这种恶行循环中

状态转移公式(递推公式)是很重要，但动态规划不仅仅只有递推公式
对于动态规划问题，这里将拆解成五步曲
这五步都掌握了，擦你能说动态规划真的掌握了

1.确定dp数组(dp table)以及下标的含义
2.确定递推公式
3.dp数组如何初始化
4.确定遍历顺序
5.举例推导dp数组

一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？
因为一些情况是递推公式决定了dp数组要如何初始化！
一些同学知道递推公式，
但搞不清楚dp数组应该如何初始化，
或者正确的遍历顺序，
以至于记下来公式，但写的程序怎么改都通过不了。
--------------------------------------------------------
动态规划如何debug？
找问题的最好方式就是把dp数组打印出来，
看看究竟是不是按照自己思路推导的！
------------------------------------------------------
举个例子：
刷题小分队微信群里，一些录友可能代码通过不了，
会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，
为什么通过不了呢？

发出这样的问题之前，其实可以自己先思考这三个问题：

* 这道题目我举例推导状态转移公式了么？
* 我打印dp数组的日志了么？
* 打印出来了dp数组和我想的一样么？
=========================================================*/