/* 

0.题目描述------------------------------------

给定一个只包含正整数的非空数组。
是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意: 
每个数组中的元素不会超过 100 
数组的大小不会超过 200

示例 1: 输入: [1, 5, 11, 5] 
输出: true 解释: 
数组可以分割成 [1, 5, 5] 和 [11].   

示例 2: 输入: [1, 2, 3, 5] 输出: false 
解释: 数组不能分割成两个元素和相等的子集.

提示：

1 <= nums.length <= 200
1 <= nums[i] <= 100 


1.思路-----------------------------------------------

这道题目初步看，是如下两题几乎是一样的，大家可以用回溯法，解决如下两题

698.划分为k个相等的子集
473.火柴拼正方形
这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。

本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。


2.01背包问题------------------------------------------------

背包问题，大家都知道，有N件物品和一个最多能被重量为W 的背包。
第i件物品的重量是weight[i]，得到的价值是value[i] 。
每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

背包问题有多种背包方式，
常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。

----
要注意题目描述中商品是不是可以重复放入。
即一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包，写法还是不一样的。
要明确本题中我们要使用的是01背包，因为元素我们只能用一次。


回归主题：--------------------------------------------------------
将问题转化为背包问题我们需要几个特征：

（1）背包重量
（2）商品重量和商品价值

首先，本题要求集合里能否出现总和为 sum / 2 的子集。
那么来一一对应一下本题，看看背包问题如果来解决。
只有确定了如下四点，才能把01背包问题套到本题上来。
（1）背包的体积为sum / 2，这个也是j的上限，
    如果到达上限的时候，从i里边挑选的东西，能够正好凑满sum/2,也就是(3)
（2）背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
（3）背包如何正好装满，说明找到了总和为 sum / 2 的子集。
（4）背包中每一个元素是不可重复放入。
以上分析完，我们就可以套用01背包，来解决这个问题了。

动归五部曲分析如下：

1.确定dp数组以及下标的含义---------------------------------

01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。
套到本题，dp[i]表示 背包总容量是i，最大可以凑成i的子集总和为dp[i]。

2.确定递推公式--------------------------------------------

01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。

所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);



3.dp数组如何初始化----------------------------------------

从dp[j]的定义来看，首先dp[0]一定是0。

如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。

这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。

本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了


4.确定遍历顺序--------------------------------------------

在动态规划：关于01背包问题，你该了解这些！（滚动数组）中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！

代码如下：

// 开始 01背包
for(int i = 0; i < nums.size(); i++) {
    for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
        dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
    }
}

5.举例推导dp数组------------------------------------------

dp[i]的数值一定是小于等于i的,因为i表示容量

如果dp[i] == i 说明，集合中的子集总和正好可以凑成总和i，
理解这一点很重要。
这里边dp[i]指的是包里边放的内容的价值。i指的是背包容量
因为nums[i]既指的是重量，又指的是价值
所以以上逻辑成立

用例1，输入[1,5,11,5] 为例，target = (1+5+11+5)/2 =11
所以我们想要求的是，当i为11的时候，也就是容量为11的时候，dp[i]的重量正好为sum/2


*/

/* javascript实现 */

var canPartition = function(nums){
    //先求和
    const sum = (nums.reduce((p,v)=> p +v));
    //然后只要偶数的，因为偶数才可以各一半
    if(sum & 1) return false;
    //初始化数组
    const dp = Array(sum/2+1).fill(0);
    for(let i = 0; i< nums.length ; i++){
        for(let j = sum/2;j>=nums[i];j--){
            dp[j] = Math.max(dp[j],dp[j-nums[i]] + nums[i]);
            if(dp[j] == sum/2){
                //跳出循环并返回值
                return true;
            }
        }
    }
    return dp[sum/2] === sum/2
}
let is =  canPartition([1,5,11,5])
console.log("--is--",is);